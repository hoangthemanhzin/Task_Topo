package ranuecontext

import (
	"etrib5gc/nfs/amf/sessioncontext"
	"etrib5gc/sbi/models"
	"etrib5gc/util/idgen"
	"math"
	"sync"
)

type PendingN1N2 struct {
	req *models.N1N2MessageTransferRequest
	sc  *sessioncontext.SessionContext
	id  uint16 //id generated by AMF
}

type N1N2Man struct {
	pending     map[uint16]*PendingN1N2
	mutex       sync.Mutex
	statusidgen idgen.IdGenerator
}

func newN1N2Man() N1N2Man {
	return N1N2Man{
		pending:     make(map[uint16]*PendingN1N2),
		statusidgen: idgen.NewIdGenerator(0, math.MaxInt16),
	}
}
func (m *N1N2Man) getTargetIds() (l []int32) {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	for _, n1n2 := range m.pending {
		l = append(l, n1n2.sc.Id())
	}
	return
}

func (m *N1N2Man) pendinglist() (l []*PendingN1N2) {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	l = make([]*PendingN1N2, len(m.pending))
	i := 0
	for _, n1n2 := range m.pending {
		l[i] = n1n2
		i++
	}
	return
}

// add the N1N2Message then return a generated identity
func (m *N1N2Man) add(sc *sessioncontext.SessionContext, msg *models.N1N2MessageTransferRequest) uint16 {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	n1n2 := &PendingN1N2{
		sc:  sc,
		req: msg,
		id:  uint16(m.statusidgen.Allocate()),
	}
	m.pending[n1n2.id] = n1n2

	return n1n2.id
}
func (m *N1N2Man) clean() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	for id, _ := range m.pending {
		m.statusidgen.Free(uint64(id))
	}
	m.pending = make(map[uint16]*PendingN1N2)
}
